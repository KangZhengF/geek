# week02作业

## 题目 01- 请你用自己的语言向我介绍 Java 运行时数据区（内存区域）

- **堆**：存储对象实例，也就是new出来的对象。
  - 分年轻代和老年代肯定是为了提高垃圾收集的效率：
    - 大多数对象朝生夕灭，只有少数会长命百岁。
    - 熬过垃圾回收的次数越多的对象越难以被清除掉（有点马太效应那味）。
    - 跨代引用相对于同代引用是极少数的，在对跨代引用对象进行垃圾回收的时候不应该扫描整个老年代。
- **虚拟机栈**：如果A方法调用B方法，B方法再调用C方法，当前处于C方法。那么虚拟机栈就是用来存储A、B、C方法的运行时信息的，比如说每个方法的入参，向下调用方法时方法内的局部变量的值等。
- **本地方法栈**：若上述C方法调用了D方法，D方法是一个native方法，则会用到本地方法栈，存储native方法执行时的参数信息等。
- **方法区**：这实际上是JVM虚拟机规范中的一个统称，在不同的JDK中，名称不一样，JDK 6中叫做永久代，JDK 8中叫做元空间，其他的JVM虚拟机实现不同，可能实际叫法不一样。用来存储类的元信息和静态变量。
- **运行时常量池**：存储代码中定义的常量；字符串常量池是单独的一部分，在JDK 7及以前是属于方法区的，在JDK 8及以后移动到了堆内存中。
- **直接内存**：不属于JVM启动运行时的内存，或者说叫做堆外的内存。大小直接取决于运行JVM的物理机器的内存大小。



## 题目 02- 描述一个 Java 对象的生命周期

- **创建过程**：类的加载、内存分配、初始化。加载就是将.class文件读取到内存中，内存分配就是在堆中为对象分配内存空间，初始化是为对象的成员变量赋初始值。
- **内存分配过程**：首先从TLAB（线程创建时会多分配一点内存给线程）中分配内存地址，如果不够，就使用CAS从堆里面划分，这时会有以下两种方式：
  - 指针碰撞：分配出连续的内存地址。
  - 空闲列表：哪里有足够的空内存，就在哪里分配，非连续内存地址。
- 销毁过程：垃圾回收器会采用可达性分析算法识别出不在被引用的对象，然后执行垃圾收集释放内存。如果调用finalize方法可能能挽救回对象，但是只能调用一次。
- 两种对象访问方式：引用对象通过引用访问，基本数据类型的对象则直接访问。
- 内存担保的原因：JVM所作的任何设计都是为了两点：1. 更少的垃圾回收次数。2. 更短的停顿或者说垃圾回收时间。由此，内存担保是为了避免新生代放不下新对象就频繁发生full gc的情况。因为很有可能我触发young gc就可以给新对象腾出足够的地方了。



## 题目 03- 垃圾收集算法有哪些？垃圾收集器有哪些？他们的特点是什么？

- 垃圾收集算法：
  - 标记-清除：直接释放掉不需要的对象的内存，会有内存碎片。
  - 标记-整理：清除之后整理内存，让存活下来的对象的内存地址连续，剩下的地址也更大，而不是零零散散的小块。
  - 复制：将存货下来的对象复制到另一块内存区域中，这块内存区域直接清除。
- 垃圾收集器：
  - ParNew 和 ParallelScavenge 收集器都是使用复制算法实现的，并行处理多个线程。
  - ParallelOld 收集器则是并行处理老年代内存，使用标记-整理算法。
  - CMS 收集器是使用标记-清除算法，并以低停顿时间为目标。
  - G1 收集器则是一种基于区域的垃圾回收器，将整个 Java 堆分为多个大小相等的区域，并以优化整体停顿时间为目标。

